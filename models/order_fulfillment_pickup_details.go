// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// OrderFulfillmentPickupDetails Contains details necessary to fulfill a pickup order.
//
// swagger:model OrderFulfillmentPickupDetails
type OrderFulfillmentPickupDetails struct {

	// The [timestamp](#workingwithdates) indicating when the fulfillment
	// was accepted. In RFC3339 timestamp format,
	// e.g., "2016-09-04T23:59:33.123Z".
	AcceptedAt string `json:"accepted_at,omitempty"`

	// The duration of time after which an open and accepted pickup fulfillment
	// will automatically move to the `COMPLETED` state. Must be in RFC3339
	// duration format e.g., "P1W3D".
	//
	// If not set, this pickup fulfillment will remain accepted until it is canceled or completed.
	AutoCompleteDuration string `json:"auto_complete_duration,omitempty"`

	// A description of why the pickup was canceled. Max length: 100 characters.
	// Max Length: 100
	CancelReason string `json:"cancel_reason,omitempty"`

	// The [timestamp](#workingwithdates) in RFC3339 timestamp format, e.g., "2016-09-04T23:59:33.123Z",
	// indicating when the fulfillment was canceled.
	CanceledAt string `json:"canceled_at,omitempty"`

	// Specific details for curbside pickup. Can only be populated if `is_curbside_pickup` is true.
	CurbsidePickupDetails *OrderFulfillmentPickupDetailsCurbsidePickupDetails `json:"curbside_pickup_details,omitempty"`

	// The [timestamp](#workingwithdates) indicating when the fulfillment expired.
	// In RFC3339 timestamp format, e.g., "2016-09-04T23:59:33.123Z".
	ExpiredAt string `json:"expired_at,omitempty"`

	// The [timestamp](#workingwithdates) indicating when this fulfillment
	// will expire if it is not accepted. Must be in RFC 3339 format
	// e.g., "2016-09-04T23:59:33.123Z". Expiration time can only be set up to 7
	// days in the future. If `expires_at` is not set, this pickup fulfillment
	// will be automatically accepted when placed.
	ExpiresAt string `json:"expires_at,omitempty"`

	// If true, indicates this pickup order is for curbside pickup, not in-store pickup.
	IsCurbsidePickup bool `json:"is_curbside_pickup,omitempty"`

	// A note meant to provide additional instructions about the pickup
	// fulfillment displayed in the Square Point of Sale and set by the API.
	// Max Length: 500
	Note string `json:"note,omitempty"`

	// The [timestamp](#workingwithdates) indicating when the fulfillment
	// was picked up by the recipient. In RFC3339 timestamp format,
	// e.g., "2016-09-04T23:59:33.123Z".
	PickedUpAt string `json:"picked_up_at,omitempty"`

	// The [timestamp](#workingwithdates) that represents the start of the pickup window.
	// Must be in RFC3339 timestamp format, e.g., "2016-09-04T23:59:33.123Z".
	// For fulfillments with the schedule type `ASAP`, this is automatically set
	// to the current time plus the expected duration to prepare the fulfillment.
	PickupAt string `json:"pickup_at,omitempty"`

	// The window of time in which the order should be picked up after the `pickup_at` timestamp.
	// Must be in RFC3339 duration format, e.g., "P1W3D". Can be used as an
	// informational guideline for merchants.
	PickupWindowDuration string `json:"pickup_window_duration,omitempty"`

	// The [timestamp](#workingwithdates) indicating when the fulfillment
	// was placed. Must be in RFC3339 timestamp format, e.g., "2016-09-04T23:59:33.123Z".
	PlacedAt string `json:"placed_at,omitempty"`

	// The duration of time it takes to prepare this fulfillment.
	// Must be in RFC3339 duration format, e.g., "P1W3D".
	PrepTimeDuration string `json:"prep_time_duration,omitempty"`

	// The [timestamp](#workingwithdates) indicating when the fulfillment is
	// marked as ready for pickup. In RFC3339 timestamp format, e.g., "2016-09-04T23:59:33.123Z".
	ReadyAt string `json:"ready_at,omitempty"`

	// Information on the person meant to pick up this fulfillment from a physical
	// location.
	Recipient *OrderFulfillmentRecipient `json:"recipient,omitempty"`

	// The [timestamp](#workingwithdates) indicating when the fulfillment
	// was rejected. In RFC3339 timestamp format, e.g., "2016-09-04T23:59:33.123Z".
	RejectedAt string `json:"rejected_at,omitempty"`

	// The schedule type of the pickup fulfillment. Defaults to `SCHEDULED`.
	// See [OrderFulfillmentPickupDetailsScheduleType](#type-orderfulfillmentpickupdetailsscheduletype) for possible values
	ScheduleType string `json:"schedule_type,omitempty"`
}

// Validate validates this order fulfillment pickup details
func (m *OrderFulfillmentPickupDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCancelReason(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurbsidePickupDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNote(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecipient(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OrderFulfillmentPickupDetails) validateCancelReason(formats strfmt.Registry) error {
	if swag.IsZero(m.CancelReason) { // not required
		return nil
	}

	if err := validate.MaxLength("cancel_reason", "body", m.CancelReason, 100); err != nil {
		return err
	}

	return nil
}

func (m *OrderFulfillmentPickupDetails) validateCurbsidePickupDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.CurbsidePickupDetails) { // not required
		return nil
	}

	if m.CurbsidePickupDetails != nil {
		if err := m.CurbsidePickupDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("curbside_pickup_details")
			}
			return err
		}
	}

	return nil
}

func (m *OrderFulfillmentPickupDetails) validateNote(formats strfmt.Registry) error {
	if swag.IsZero(m.Note) { // not required
		return nil
	}

	if err := validate.MaxLength("note", "body", m.Note, 500); err != nil {
		return err
	}

	return nil
}

func (m *OrderFulfillmentPickupDetails) validateRecipient(formats strfmt.Registry) error {
	if swag.IsZero(m.Recipient) { // not required
		return nil
	}

	if m.Recipient != nil {
		if err := m.Recipient.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recipient")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this order fulfillment pickup details based on the context it is used
func (m *OrderFulfillmentPickupDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCurbsidePickupDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRecipient(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OrderFulfillmentPickupDetails) contextValidateCurbsidePickupDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.CurbsidePickupDetails != nil {
		if err := m.CurbsidePickupDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("curbside_pickup_details")
			}
			return err
		}
	}

	return nil
}

func (m *OrderFulfillmentPickupDetails) contextValidateRecipient(ctx context.Context, formats strfmt.Registry) error {

	if m.Recipient != nil {
		if err := m.Recipient.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recipient")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OrderFulfillmentPickupDetails) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OrderFulfillmentPickupDetails) UnmarshalBinary(b []byte) error {
	var res OrderFulfillmentPickupDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
