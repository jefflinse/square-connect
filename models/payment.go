// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Payment Represents a payment processed by the Square API.
//
// swagger:model Payment
type Payment struct {

	// The amount of money processed for this payment, not including `tip_money`.
	// Specified in the smallest denomination of the applicable currency. For example,
	// US dollar amounts are specified in cents. For more information, see
	// [Working with monetary amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts).
	AmountMoney *Money `json:"amount_money,omitempty"`

	// The amount of money the developer is taking as a fee
	// for facilitating the payment on behalf of the seller. Specified in the
	// smallest denomination of the applicable currency. For example, US dollar
	// amounts are specified in cents.
	//
	// For more information, see
	// [Take Payments and Collect Fees](https://developer.squareup.com/docs/payments-api/take-payments-and-collect-fees).
	//
	// Cannot be more than 90% of the `total_money` value.
	AppFeeMoney *Money `json:"app_fee_money,omitempty"`

	// The buyer's billing address
	BillingAddress *Address `json:"billing_address,omitempty"`

	// The buyer's e-mail address
	// Max Length: 255
	BuyerEmailAddress string `json:"buyer_email_address,omitempty"`

	// Non-confidential details about the source. Only populated if the
	// `source_type` is `CARD`.
	CardDetails *CardPaymentDetails `json:"card_details,omitempty"`

	// Timestamp of when the payment was created, in RFC 3339 format.
	// Max Length: 32
	CreatedAt string `json:"created_at,omitempty"`

	// The `Customer` ID of the customer associated with the payment.
	// Max Length: 191
	CustomerID string `json:"customer_id,omitempty"`

	// The action to be applied to the payment when the `delay_duration` has elapsed. This field
	// is read only.
	//
	// Current values include:
	// `CANCEL`
	DelayAction string `json:"delay_action,omitempty"`

	// The duration of time after the payment's creation when Square automatically applies the
	// `delay_action` to the payment. This automatic `delay_action` applies only to payments that
	// don't reach a terminal state (COMPLETED, CANCELED, or FAILED) before the `delay_duration`
	// time period.
	//
	// This field is specified as a time duration, in RFC 3339 format.
	//
	// Notes:
	// This feature is only supported for card payments.
	//
	// Default:
	//
	// - Card Present payments: "PT36H" (36 hours) from the creation time.
	// - Card Not Present payments: "P7D" (7 days) from the creation time.
	DelayDuration string `json:"delay_duration,omitempty"`

	// Read only timestamp of when the `delay_action` will automatically be applied,
	// in RFC 3339 format.
	//
	// Note that this field is calculated by summing the payment's `delay_duration` and `created_at`
	// fields. The `created_at` field is generated by Square and may not exactly match the
	// time on your local machine.
	DelayedUntil string `json:"delayed_until,omitempty"`

	// An optional ID of the employee associated with taking this payment.
	// Max Length: 192
	EmployeeID string `json:"employee_id,omitempty"`

	// Unique ID for the payment.
	// Max Length: 192
	ID string `json:"id,omitempty"`

	// ID of the location associated with the payment.
	// Max Length: 50
	LocationID string `json:"location_id,omitempty"`

	// An optional note to include when creating a payment
	// Max Length: 500
	Note string `json:"note,omitempty"`

	// ID of the order associated with this payment.
	// Max Length: 192
	OrderID string `json:"order_id,omitempty"`

	// Processing fees and fee adjustments assessed by Square on this payment.
	ProcessingFee []*ProcessingFee `json:"processing_fee"`

	// The payment's receipt number.
	// The field will be missing if a payment is CANCELED
	// Max Length: 4
	ReceiptNumber string `json:"receipt_number,omitempty"`

	// The URL for the payment's receipt.
	// The field will only be populated for COMPLETED payments.
	// Max Length: 255
	ReceiptURL string `json:"receipt_url,omitempty"`

	// An optional ID that associates this payment with an entity in
	// another system.
	// Max Length: 40
	ReferenceID string `json:"reference_id,omitempty"`

	// List of `refund_id`s identifying refunds for this payment.
	RefundIds []string `json:"refund_ids"`

	// Total amount of the payment refunded to-date. Specified
	// in the smallest denomination of the applicable currency. For example, US
	// dollar amounts are specified in cents.
	RefundedMoney *Money `json:"refunded_money,omitempty"`

	// The buyer's shipping address
	ShippingAddress *Address `json:"shipping_address,omitempty"`

	// The source type for this payment
	//
	// Current values include: `CARD`.
	// Max Length: 50
	SourceType string `json:"source_type,omitempty"`

	// Additional payment information that gets added on the customer's card statement
	// as part of the statement description.
	//
	// Note that the `statement_description_identifier` may get truncated on the statement description
	// to fit the required information including the Square identifier (SQ *) and name of the
	// merchant taking the payment.
	StatementDescriptionIdentifier string `json:"statement_description_identifier,omitempty"`

	// Indicates whether the payment is `APPROVED`, `COMPLETED`, `CANCELED`, or `FAILED`.
	// Max Length: 50
	Status string `json:"status,omitempty"`

	// The amount designated as a tip. Specified in the
	// smallest denomination of the applicable currency. For example, US dollar
	// amounts are specified in cents.
	TipMoney *Money `json:"tip_money,omitempty"`

	// The total money for the payment, including `amount_money` and `tip_money`.
	// Specified in the smallest denomination of the applicable currency.
	// For example, US dollar amounts are specified in cents.
	TotalMoney *Money `json:"total_money,omitempty"`

	// Timestamp of when the payment was last updated, in RFC 3339 format.
	// Max Length: 32
	UpdatedAt string `json:"updated_at,omitempty"`
}

// Validate validates this payment
func (m *Payment) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmountMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAppFeeMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBillingAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBuyerEmailAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCardDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomerID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmployeeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocationID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNote(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProcessingFee(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReceiptNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReceiptURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReferenceID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRefundedMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShippingAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTipMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Payment) validateAmountMoney(formats strfmt.Registry) error {

	if swag.IsZero(m.AmountMoney) { // not required
		return nil
	}

	if m.AmountMoney != nil {
		if err := m.AmountMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("amount_money")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateAppFeeMoney(formats strfmt.Registry) error {

	if swag.IsZero(m.AppFeeMoney) { // not required
		return nil
	}

	if m.AppFeeMoney != nil {
		if err := m.AppFeeMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("app_fee_money")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateBillingAddress(formats strfmt.Registry) error {

	if swag.IsZero(m.BillingAddress) { // not required
		return nil
	}

	if m.BillingAddress != nil {
		if err := m.BillingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billing_address")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateBuyerEmailAddress(formats strfmt.Registry) error {

	if swag.IsZero(m.BuyerEmailAddress) { // not required
		return nil
	}

	if err := validate.MaxLength("buyer_email_address", "body", string(m.BuyerEmailAddress), 255); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateCardDetails(formats strfmt.Registry) error {

	if swag.IsZero(m.CardDetails) { // not required
		return nil
	}

	if m.CardDetails != nil {
		if err := m.CardDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("card_details")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateCreatedAt(formats strfmt.Registry) error {

	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if err := validate.MaxLength("created_at", "body", string(m.CreatedAt), 32); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateCustomerID(formats strfmt.Registry) error {

	if swag.IsZero(m.CustomerID) { // not required
		return nil
	}

	if err := validate.MaxLength("customer_id", "body", string(m.CustomerID), 191); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateEmployeeID(formats strfmt.Registry) error {

	if swag.IsZero(m.EmployeeID) { // not required
		return nil
	}

	if err := validate.MaxLength("employee_id", "body", string(m.EmployeeID), 192); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateID(formats strfmt.Registry) error {

	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("id", "body", string(m.ID), 192); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateLocationID(formats strfmt.Registry) error {

	if swag.IsZero(m.LocationID) { // not required
		return nil
	}

	if err := validate.MaxLength("location_id", "body", string(m.LocationID), 50); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateNote(formats strfmt.Registry) error {

	if swag.IsZero(m.Note) { // not required
		return nil
	}

	if err := validate.MaxLength("note", "body", string(m.Note), 500); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateOrderID(formats strfmt.Registry) error {

	if swag.IsZero(m.OrderID) { // not required
		return nil
	}

	if err := validate.MaxLength("order_id", "body", string(m.OrderID), 192); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateProcessingFee(formats strfmt.Registry) error {

	if swag.IsZero(m.ProcessingFee) { // not required
		return nil
	}

	for i := 0; i < len(m.ProcessingFee); i++ {
		if swag.IsZero(m.ProcessingFee[i]) { // not required
			continue
		}

		if m.ProcessingFee[i] != nil {
			if err := m.ProcessingFee[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("processing_fee" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Payment) validateReceiptNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.ReceiptNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("receipt_number", "body", string(m.ReceiptNumber), 4); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateReceiptURL(formats strfmt.Registry) error {

	if swag.IsZero(m.ReceiptURL) { // not required
		return nil
	}

	if err := validate.MaxLength("receipt_url", "body", string(m.ReceiptURL), 255); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateReferenceID(formats strfmt.Registry) error {

	if swag.IsZero(m.ReferenceID) { // not required
		return nil
	}

	if err := validate.MaxLength("reference_id", "body", string(m.ReferenceID), 40); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateRefundedMoney(formats strfmt.Registry) error {

	if swag.IsZero(m.RefundedMoney) { // not required
		return nil
	}

	if m.RefundedMoney != nil {
		if err := m.RefundedMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refunded_money")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateShippingAddress(formats strfmt.Registry) error {

	if swag.IsZero(m.ShippingAddress) { // not required
		return nil
	}

	if m.ShippingAddress != nil {
		if err := m.ShippingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shipping_address")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateSourceType(formats strfmt.Registry) error {

	if swag.IsZero(m.SourceType) { // not required
		return nil
	}

	if err := validate.MaxLength("source_type", "body", string(m.SourceType), 50); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.Status) { // not required
		return nil
	}

	if err := validate.MaxLength("status", "body", string(m.Status), 50); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateTipMoney(formats strfmt.Registry) error {

	if swag.IsZero(m.TipMoney) { // not required
		return nil
	}

	if m.TipMoney != nil {
		if err := m.TipMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tip_money")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateTotalMoney(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalMoney) { // not required
		return nil
	}

	if m.TotalMoney != nil {
		if err := m.TotalMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total_money")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateUpdatedAt(formats strfmt.Registry) error {

	if swag.IsZero(m.UpdatedAt) { // not required
		return nil
	}

	if err := validate.MaxLength("updated_at", "body", string(m.UpdatedAt), 32); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Payment) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Payment) UnmarshalBinary(b []byte) error {
	var res Payment
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
