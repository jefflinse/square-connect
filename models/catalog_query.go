// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// CatalogQuery A query to be applied to a `SearchCatalogObjectsRequest`.
// Only one query field may be present.
//
// Where an attribute name is required, it should be specified as the name of any field
// marked "searchable" from the structured data types for the desired result object type(s)
// (`CatalogItem`, `CatalogItemVariation`, `CatalogCategory`, `CatalogTax`,
// `CatalogDiscount`, `CatalogModifierList`, `CatalogModifier`).
//
// For example, a query that should return Items may specify attribute names from
// any of the searchable fields of the `CatalogItem` data type, namely
// `"name"`, `"description"`, and `"abbreviation"`.
//
// swagger:model CatalogQuery
type CatalogQuery struct {

	// A query that returns only objects for which the given (string-valued) attribute has the
	// given case-insensitive value.
	ExactQuery *CatalogQueryExact `json:"exact_query,omitempty"`

	// A query that returns all `CatalogItemVariation`s that have all of the given `CatalogItemOption` values.
	ItemVariationsForItemOptionValuesQuery *CatalogQueryItemVariationsForItemOptionValues `json:"item_variations_for_item_option_values_query,omitempty"`

	// A query that returns all `CatalogItem`s that have all of the given `CatalogItemOption`s.
	ItemsForItemOptionsQuery *CatalogQueryItemsForItemOptions `json:"items_for_item_options_query,omitempty"`

	// A query that returns all `CatalogItem`s that have any of the given `CatalogModifierList`s enabled.
	ItemsForModifierListQuery *CatalogQueryItemsForModifierList `json:"items_for_modifier_list_query,omitempty"`

	// A query that returns all `CatalogItem`s that have any of the given `CatalogTax`es enabled.
	ItemsForTaxQuery *CatalogQueryItemsForTax `json:"items_for_tax_query,omitempty"`

	// A query that returns only objects for which the given (string-valued) attribute has the
	// given case-insensitive prefix.
	PrefixQuery *CatalogQueryPrefix `json:"prefix_query,omitempty"`

	// A query that returns only objects for which the given (integer-valued) attribute lies in the given range.
	RangeQuery *CatalogQueryRange `json:"range_query,omitempty"`

	// A query that returns all objects, sorted by the given attribute.
	SortedAttributeQuery *CatalogQuerySortedAttribute `json:"sorted_attribute_query,omitempty"`

	// A query that returns only objects whose searchable attributes contain all of the given
	// keywords as prefixes. For example, if a `CatalogItem` contains attributes `{"name": "t-shirt"}` and
	// `{"description": "Small, Purple"}`, it will be matched by the query `{"keywords": ["shirt", "sma", "purp"]}`.
	TextQuery *CatalogQueryText `json:"text_query,omitempty"`
}

// Validate validates this catalog query
func (m *CatalogQuery) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateExactQuery(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateItemVariationsForItemOptionValuesQuery(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateItemsForItemOptionsQuery(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateItemsForModifierListQuery(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateItemsForTaxQuery(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrefixQuery(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRangeQuery(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSortedAttributeQuery(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTextQuery(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CatalogQuery) validateExactQuery(formats strfmt.Registry) error {

	if swag.IsZero(m.ExactQuery) { // not required
		return nil
	}

	if m.ExactQuery != nil {
		if err := m.ExactQuery.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("exact_query")
			}
			return err
		}
	}

	return nil
}

func (m *CatalogQuery) validateItemVariationsForItemOptionValuesQuery(formats strfmt.Registry) error {

	if swag.IsZero(m.ItemVariationsForItemOptionValuesQuery) { // not required
		return nil
	}

	if m.ItemVariationsForItemOptionValuesQuery != nil {
		if err := m.ItemVariationsForItemOptionValuesQuery.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("item_variations_for_item_option_values_query")
			}
			return err
		}
	}

	return nil
}

func (m *CatalogQuery) validateItemsForItemOptionsQuery(formats strfmt.Registry) error {

	if swag.IsZero(m.ItemsForItemOptionsQuery) { // not required
		return nil
	}

	if m.ItemsForItemOptionsQuery != nil {
		if err := m.ItemsForItemOptionsQuery.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("items_for_item_options_query")
			}
			return err
		}
	}

	return nil
}

func (m *CatalogQuery) validateItemsForModifierListQuery(formats strfmt.Registry) error {

	if swag.IsZero(m.ItemsForModifierListQuery) { // not required
		return nil
	}

	if m.ItemsForModifierListQuery != nil {
		if err := m.ItemsForModifierListQuery.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("items_for_modifier_list_query")
			}
			return err
		}
	}

	return nil
}

func (m *CatalogQuery) validateItemsForTaxQuery(formats strfmt.Registry) error {

	if swag.IsZero(m.ItemsForTaxQuery) { // not required
		return nil
	}

	if m.ItemsForTaxQuery != nil {
		if err := m.ItemsForTaxQuery.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("items_for_tax_query")
			}
			return err
		}
	}

	return nil
}

func (m *CatalogQuery) validatePrefixQuery(formats strfmt.Registry) error {

	if swag.IsZero(m.PrefixQuery) { // not required
		return nil
	}

	if m.PrefixQuery != nil {
		if err := m.PrefixQuery.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("prefix_query")
			}
			return err
		}
	}

	return nil
}

func (m *CatalogQuery) validateRangeQuery(formats strfmt.Registry) error {

	if swag.IsZero(m.RangeQuery) { // not required
		return nil
	}

	if m.RangeQuery != nil {
		if err := m.RangeQuery.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("range_query")
			}
			return err
		}
	}

	return nil
}

func (m *CatalogQuery) validateSortedAttributeQuery(formats strfmt.Registry) error {

	if swag.IsZero(m.SortedAttributeQuery) { // not required
		return nil
	}

	if m.SortedAttributeQuery != nil {
		if err := m.SortedAttributeQuery.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sorted_attribute_query")
			}
			return err
		}
	}

	return nil
}

func (m *CatalogQuery) validateTextQuery(formats strfmt.Registry) error {

	if swag.IsZero(m.TextQuery) { // not required
		return nil
	}

	if m.TextQuery != nil {
		if err := m.TextQuery.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("text_query")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CatalogQuery) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CatalogQuery) UnmarshalBinary(b []byte) error {
	var res CatalogQuery
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
