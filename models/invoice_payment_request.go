// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// InvoicePaymentRequest Represents a payment request for an [invoice](#type-Invoice). Invoices can specify a maximum
// of 13 payment requests, with up to 12 `INSTALLMENT` request types.
//
// For more information,
// see [Payment requests](/docs/invoices-api/overview#payment-requests).
//
// swagger:model InvoicePaymentRequest
type InvoicePaymentRequest struct {

	// The payment method for an automatic payment.
	//
	// The default value is `NONE`.
	// See [InvoiceAutomaticPaymentSource](#type-invoiceautomaticpaymentsource) for possible values
	AutomaticPaymentSource string `json:"automatic_payment_source,omitempty"`

	// The ID of the card on file to charge for the payment request. To get the customerâ€™s card on file,
	// use the `customer_id` of the invoice recipient to call `RetrieveCustomer`
	// in the Customers API. Then, get the ID of the target card from the `cards` field in the response.
	// Max Length: 255
	// Min Length: 1
	CardID string `json:"card_id,omitempty"`

	// The amount of the payment request, computed using the order amount and information from the various payment request fields (`request_type`,
	// `fixed_amount_requested_money`, and `percentage_requested`).
	ComputedAmountMoney *Money `json:"computed_amount_money,omitempty"`

	// The due date (in the invoice location's time zone) for the payment request, in `YYYY-MM-DD` format.
	// After this date, the invoice becomes overdue. This field is required to create a payment request.
	DueDate string `json:"due_date,omitempty"`

	// If the payment request specifies `DEPOSIT` or `INSTALLMENT` as the
	// `request_type`,
	// this indicates the request amount.
	// You cannot specify this when `request_type` is `BALANCE` or when the
	// payment request includes the `percentage_requested` field.
	FixedAmountRequestedMoney *Money `json:"fixed_amount_requested_money,omitempty"`

	// Specifies the amount for the payment request in percentage:
	//
	// - When the payment `request_type` is `DEPOSIT`, it is the percentage of the order total amount.
	// - When the payment `request_type` is `INSTALLMENT`, it is the percentage of the order total less
	// the deposit, if requested. The sum of the `percentage_requested` in all installment
	// payment requests must be equal to 100.
	//
	// You cannot specify this when the payment `request_type` is `BALANCE` or when the
	// payment request specifies the `fixed_amount_requested_money` field.
	PercentageRequested string `json:"percentage_requested,omitempty"`

	// A list of one or more reminders to send for the payment request.
	Reminders []*InvoicePaymentReminder `json:"reminders"`

	// Indicates how Square processes the payment request. DEPRECATED at version 2021-01-21. Replaced by the `Invoice.delivery_method` and `InvoicePaymentRequest.automatic_payment_source` fields.
	//
	// One of the following is required when creating an invoice:
	// - (Recommended) The `delivery_method` field of the invoice. To configure an automatic payment, the `automatic_payment_source` field of the payment request is also required.
	// - This `request_method` field. Note that `invoice` objects returned in responses do not include `request_method`.
	// See [InvoiceRequestMethod](#type-invoicerequestmethod) for possible values
	RequestMethod string `json:"request_method,omitempty"`

	// Identifies the payment request type. This type defines how the payment request amount is determined. This field is required to create a payment request.
	// See [InvoiceRequestType](#type-invoicerequesttype) for possible values
	RequestType string `json:"request_type,omitempty"`

	// If the most recent payment was a cash payment
	// in a currency that rounds cash payments (such as, `CAD` or `AUD`) and the payment
	// is rounded from `computed_amount_money` in the payment request, then this
	// field specifies the rounding adjustment applied. This amount
	// might be negative.
	RoundingAdjustmentIncludedMoney *Money `json:"rounding_adjustment_included_money,omitempty"`

	// If set to true, the Square-hosted invoice page (the `public_url` field of the invoice)
	// provides a place for the customer to pay a tip.
	//
	// This field is allowed only on the final payment request
	// and the payment `request_type` must be `BALANCE` or `INSTALLMENT`.
	TippingEnabled bool `json:"tipping_enabled,omitempty"`

	// The amount of money already paid for the specific payment request.
	// This amount might include a rounding adjustment if the most recent invoice payment
	// was in cash in a currency that rounds cash payments (such as, `CAD` or `AUD`).
	TotalCompletedAmountMoney *Money `json:"total_completed_amount_money,omitempty"`

	// The Square-generated ID of the payment request in an `invoice`.
	// Max Length: 255
	// Min Length: 1
	UID string `json:"uid,omitempty"`
}

// Validate validates this invoice payment request
func (m *InvoicePaymentRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCardID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputedAmountMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFixedAmountRequestedMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReminders(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRoundingAdjustmentIncludedMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalCompletedAmountMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *InvoicePaymentRequest) validateCardID(formats strfmt.Registry) error {
	if swag.IsZero(m.CardID) { // not required
		return nil
	}

	if err := validate.MinLength("card_id", "body", m.CardID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("card_id", "body", m.CardID, 255); err != nil {
		return err
	}

	return nil
}

func (m *InvoicePaymentRequest) validateComputedAmountMoney(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputedAmountMoney) { // not required
		return nil
	}

	if m.ComputedAmountMoney != nil {
		if err := m.ComputedAmountMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computed_amount_money")
			}
			return err
		}
	}

	return nil
}

func (m *InvoicePaymentRequest) validateFixedAmountRequestedMoney(formats strfmt.Registry) error {
	if swag.IsZero(m.FixedAmountRequestedMoney) { // not required
		return nil
	}

	if m.FixedAmountRequestedMoney != nil {
		if err := m.FixedAmountRequestedMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fixed_amount_requested_money")
			}
			return err
		}
	}

	return nil
}

func (m *InvoicePaymentRequest) validateReminders(formats strfmt.Registry) error {
	if swag.IsZero(m.Reminders) { // not required
		return nil
	}

	for i := 0; i < len(m.Reminders); i++ {
		if swag.IsZero(m.Reminders[i]) { // not required
			continue
		}

		if m.Reminders[i] != nil {
			if err := m.Reminders[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("reminders" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *InvoicePaymentRequest) validateRoundingAdjustmentIncludedMoney(formats strfmt.Registry) error {
	if swag.IsZero(m.RoundingAdjustmentIncludedMoney) { // not required
		return nil
	}

	if m.RoundingAdjustmentIncludedMoney != nil {
		if err := m.RoundingAdjustmentIncludedMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rounding_adjustment_included_money")
			}
			return err
		}
	}

	return nil
}

func (m *InvoicePaymentRequest) validateTotalCompletedAmountMoney(formats strfmt.Registry) error {
	if swag.IsZero(m.TotalCompletedAmountMoney) { // not required
		return nil
	}

	if m.TotalCompletedAmountMoney != nil {
		if err := m.TotalCompletedAmountMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total_completed_amount_money")
			}
			return err
		}
	}

	return nil
}

func (m *InvoicePaymentRequest) validateUID(formats strfmt.Registry) error {
	if swag.IsZero(m.UID) { // not required
		return nil
	}

	if err := validate.MinLength("uid", "body", m.UID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("uid", "body", m.UID, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this invoice payment request based on the context it is used
func (m *InvoicePaymentRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputedAmountMoney(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFixedAmountRequestedMoney(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReminders(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRoundingAdjustmentIncludedMoney(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTotalCompletedAmountMoney(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *InvoicePaymentRequest) contextValidateComputedAmountMoney(ctx context.Context, formats strfmt.Registry) error {

	if m.ComputedAmountMoney != nil {
		if err := m.ComputedAmountMoney.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computed_amount_money")
			}
			return err
		}
	}

	return nil
}

func (m *InvoicePaymentRequest) contextValidateFixedAmountRequestedMoney(ctx context.Context, formats strfmt.Registry) error {

	if m.FixedAmountRequestedMoney != nil {
		if err := m.FixedAmountRequestedMoney.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fixed_amount_requested_money")
			}
			return err
		}
	}

	return nil
}

func (m *InvoicePaymentRequest) contextValidateReminders(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Reminders); i++ {

		if m.Reminders[i] != nil {
			if err := m.Reminders[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("reminders" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *InvoicePaymentRequest) contextValidateRoundingAdjustmentIncludedMoney(ctx context.Context, formats strfmt.Registry) error {

	if m.RoundingAdjustmentIncludedMoney != nil {
		if err := m.RoundingAdjustmentIncludedMoney.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rounding_adjustment_included_money")
			}
			return err
		}
	}

	return nil
}

func (m *InvoicePaymentRequest) contextValidateTotalCompletedAmountMoney(ctx context.Context, formats strfmt.Registry) error {

	if m.TotalCompletedAmountMoney != nil {
		if err := m.TotalCompletedAmountMoney.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total_completed_amount_money")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *InvoicePaymentRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *InvoicePaymentRequest) UnmarshalBinary(b []byte) error {
	var res InvoicePaymentRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
