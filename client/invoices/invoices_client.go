// Code generated by go-swagger; DO NOT EDIT.

package invoices

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new invoices API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for invoices API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	CancelInvoice(params *CancelInvoiceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CancelInvoiceOK, error)

	CreateInvoice(params *CreateInvoiceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateInvoiceOK, error)

	DeleteInvoice(params *DeleteInvoiceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteInvoiceOK, error)

	GetInvoice(params *GetInvoiceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetInvoiceOK, error)

	ListInvoices(params *ListInvoicesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListInvoicesOK, error)

	PublishInvoice(params *PublishInvoiceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PublishInvoiceOK, error)

	SearchInvoices(params *SearchInvoicesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SearchInvoicesOK, error)

	UpdateInvoice(params *UpdateInvoiceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateInvoiceOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  CancelInvoice cancels invoice

  Cancels an invoice. The seller cannot collect payments for
the canceled invoice.

You cannot cancel an invoice in the `DRAFT` state or in a terminal state: `PAID`, `REFUNDED`, `CANCELED`, or `FAILED`.
*/
func (a *Client) CancelInvoice(params *CancelInvoiceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CancelInvoiceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCancelInvoiceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CancelInvoice",
		Method:             "POST",
		PathPattern:        "/v2/invoices/{invoice_id}/cancel",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CancelInvoiceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CancelInvoiceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for CancelInvoice: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CreateInvoice creates invoice

  Creates a draft [invoice](#type-invoice)
for an order created using the Orders API.

A draft invoice remains in your account and no action is taken.
You must publish the invoice before Square can process it (send it to the customer's email address or charge the customerâ€™s card on file).
*/
func (a *Client) CreateInvoice(params *CreateInvoiceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateInvoiceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateInvoiceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateInvoice",
		Method:             "POST",
		PathPattern:        "/v2/invoices",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateInvoiceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateInvoiceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for CreateInvoice: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DeleteInvoice deletes invoice

  Deletes the specified invoice. When an invoice is deleted, the
associated Order status changes to CANCELED. You can only delete a draft
invoice (you cannot delete a published invoice, including one that is scheduled for processing).
*/
func (a *Client) DeleteInvoice(params *DeleteInvoiceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteInvoiceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteInvoiceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteInvoice",
		Method:             "DELETE",
		PathPattern:        "/v2/invoices/{invoice_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteInvoiceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteInvoiceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for DeleteInvoice: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetInvoice gets invoice

  Retrieves an invoice by invoice ID.
*/
func (a *Client) GetInvoice(params *GetInvoiceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetInvoiceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetInvoiceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetInvoice",
		Method:             "GET",
		PathPattern:        "/v2/invoices/{invoice_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetInvoiceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetInvoiceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetInvoice: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ListInvoices lists invoices

  Returns a list of invoices for a given location. The response
is paginated. If truncated, the response includes a `cursor` that you
use in a subsequent request to fetch the next set of invoices.
*/
func (a *Client) ListInvoices(params *ListInvoicesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListInvoicesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListInvoicesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListInvoices",
		Method:             "GET",
		PathPattern:        "/v2/invoices",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListInvoicesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListInvoicesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ListInvoices: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PublishInvoice publishes invoice

  Publishes the specified draft invoice.

After an invoice is published, Square
follows up based on the invoice configuration. For example, Square
sends the invoice to the customer's email address, charges the customer's card on file, or does
nothing. Square also makes the invoice available on a Square-hosted invoice page.

The invoice `status` also changes from `DRAFT` to a status
based on the invoice configuration. For example, the status changes to `UNPAID` if
Square emails the invoice or `PARTIALLY_PAID` if Square charge a card on file for a portion of the
invoice amount).
*/
func (a *Client) PublishInvoice(params *PublishInvoiceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PublishInvoiceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublishInvoiceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "PublishInvoice",
		Method:             "POST",
		PathPattern:        "/v2/invoices/{invoice_id}/publish",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PublishInvoiceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PublishInvoiceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for PublishInvoice: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SearchInvoices searches invoices

  Searches for invoices from a location specified in
the filter. You can optionally specify customers in the filter for whom to
retrieve invoices. In the current implementation, you can only specify one location and
optionally one customer.

The response is paginated. If truncated, the response includes a `cursor`
that you use in a subsequent request to fetch the next set of invoices.
*/
func (a *Client) SearchInvoices(params *SearchInvoicesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SearchInvoicesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSearchInvoicesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "SearchInvoices",
		Method:             "POST",
		PathPattern:        "/v2/invoices/search",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SearchInvoicesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SearchInvoicesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for SearchInvoices: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  UpdateInvoice updates invoice

  Updates an invoice by modifying fields, clearing fields, or both. For most updates, you can use a sparse
`Invoice` object to add fields or change values, and use the `fields_to_clear` field to specify fields to clear.
However, some restrictions apply. For example, you cannot change the `order_id` or `location_id` field, and you
must provide the complete `custom_fields` list to update a custom field. Published invoices have additional restrictions.
*/
func (a *Client) UpdateInvoice(params *UpdateInvoiceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateInvoiceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateInvoiceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateInvoice",
		Method:             "PUT",
		PathPattern:        "/v2/invoices/{invoice_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateInvoiceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateInvoiceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for UpdateInvoice: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
