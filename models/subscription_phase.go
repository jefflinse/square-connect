// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SubscriptionPhase Describes a phase in a subscription plan. For more information, see
// [Set Up and Manage a Subscription Plan](/docs/subscriptions-api/setup-plan).
//
// swagger:model SubscriptionPhase
type SubscriptionPhase struct {

	// The billing cadence of the phase. For example, weekly or monthly. This field cannot be changed after a `SubscriptionPhase` is created.
	// See [SubscriptionCadence](#type-subscriptioncadence) for possible values
	// Required: true
	Cadence *string `json:"cadence"`

	// The position this phase appears in the sequence of phases defined for the plan, indexed from 0. This field cannot be changed after a `SubscriptionPhase` is created.
	Ordinal int64 `json:"ordinal,omitempty"`

	// The number of `cadence`s the phase lasts. If not set, the phase never ends. Only the last phase can be indefinite. This field cannot be changed after a `SubscriptionPhase` is created.
	Periods int64 `json:"periods,omitempty"`

	// The amount to bill for each `cadence`.
	// Required: true
	RecurringPriceMoney *Money `json:"recurring_price_money"`

	// The Square-assigned ID of the subscription phase. This field cannot be changed after a `SubscriptionPhase` is created.
	UID string `json:"uid,omitempty"`
}

// Validate validates this subscription phase
func (m *SubscriptionPhase) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCadence(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecurringPriceMoney(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SubscriptionPhase) validateCadence(formats strfmt.Registry) error {

	if err := validate.Required("cadence", "body", m.Cadence); err != nil {
		return err
	}

	return nil
}

func (m *SubscriptionPhase) validateRecurringPriceMoney(formats strfmt.Registry) error {

	if err := validate.Required("recurring_price_money", "body", m.RecurringPriceMoney); err != nil {
		return err
	}

	if m.RecurringPriceMoney != nil {
		if err := m.RecurringPriceMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recurring_price_money")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this subscription phase based on the context it is used
func (m *SubscriptionPhase) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateRecurringPriceMoney(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SubscriptionPhase) contextValidateRecurringPriceMoney(ctx context.Context, formats strfmt.Registry) error {

	if m.RecurringPriceMoney != nil {
		if err := m.RecurringPriceMoney.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recurring_price_money")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SubscriptionPhase) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SubscriptionPhase) UnmarshalBinary(b []byte) error {
	var res SubscriptionPhase
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
