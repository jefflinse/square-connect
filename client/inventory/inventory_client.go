// Code generated by go-swagger; DO NOT EDIT.

package inventory

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new inventory API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for inventory API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	BatchChangeInventory(params *BatchChangeInventoryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BatchChangeInventoryOK, error)

	BatchRetrieveInventoryChanges(params *BatchRetrieveInventoryChangesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BatchRetrieveInventoryChangesOK, error)

	BatchRetrieveInventoryCounts(params *BatchRetrieveInventoryCountsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BatchRetrieveInventoryCountsOK, error)

	RetrieveInventoryAdjustment(params *RetrieveInventoryAdjustmentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RetrieveInventoryAdjustmentOK, error)

	RetrieveInventoryChanges(params *RetrieveInventoryChangesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RetrieveInventoryChangesOK, error)

	RetrieveInventoryCount(params *RetrieveInventoryCountParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RetrieveInventoryCountOK, error)

	RetrieveInventoryPhysicalCount(params *RetrieveInventoryPhysicalCountParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RetrieveInventoryPhysicalCountOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  BatchChangeInventory batches change inventory

  Applies adjustments and counts to the provided item quantities.

On success: returns the current calculated counts for all objects
referenced in the request.
On failure: returns a list of related errors.
*/
func (a *Client) BatchChangeInventory(params *BatchChangeInventoryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BatchChangeInventoryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBatchChangeInventoryParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "BatchChangeInventory",
		Method:             "POST",
		PathPattern:        "/v2/inventory/batch-change",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BatchChangeInventoryReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BatchChangeInventoryOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for BatchChangeInventory: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  BatchRetrieveInventoryChanges batches retrieve inventory changes

  Returns historical physical counts and adjustments based on the
provided filter criteria.

Results are paginated and sorted in ascending order according their
`occurred_at` timestamp (oldest first).

BatchRetrieveInventoryChanges is a catch-all query endpoint for queries
that cannot be handled by other, simpler endpoints.
*/
func (a *Client) BatchRetrieveInventoryChanges(params *BatchRetrieveInventoryChangesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BatchRetrieveInventoryChangesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBatchRetrieveInventoryChangesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "BatchRetrieveInventoryChanges",
		Method:             "POST",
		PathPattern:        "/v2/inventory/batch-retrieve-changes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BatchRetrieveInventoryChangesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BatchRetrieveInventoryChangesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for BatchRetrieveInventoryChanges: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  BatchRetrieveInventoryCounts batches retrieve inventory counts

  Returns current counts for the provided
[CatalogObject](#type-catalogobject)s at the requested
[Location](#type-location)s.

Results are paginated and sorted in descending order according to their
`calculated_at` timestamp (newest first).

When `updated_after` is specified, only counts that have changed since that
time (based on the server timestamp for the most recent change) are
returned. This allows clients to perform a "sync" operation, for example
in response to receiving a Webhook notification.
*/
func (a *Client) BatchRetrieveInventoryCounts(params *BatchRetrieveInventoryCountsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BatchRetrieveInventoryCountsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBatchRetrieveInventoryCountsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "BatchRetrieveInventoryCounts",
		Method:             "POST",
		PathPattern:        "/v2/inventory/batch-retrieve-counts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BatchRetrieveInventoryCountsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BatchRetrieveInventoryCountsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for BatchRetrieveInventoryCounts: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RetrieveInventoryAdjustment retrieves inventory adjustment

  Returns the [InventoryAdjustment](#type-inventoryadjustment) object
with the provided `adjustment_id`.
*/
func (a *Client) RetrieveInventoryAdjustment(params *RetrieveInventoryAdjustmentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RetrieveInventoryAdjustmentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRetrieveInventoryAdjustmentParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RetrieveInventoryAdjustment",
		Method:             "GET",
		PathPattern:        "/v2/inventory/adjustment/{adjustment_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RetrieveInventoryAdjustmentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RetrieveInventoryAdjustmentOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RetrieveInventoryAdjustment: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RetrieveInventoryChanges retrieves inventory changes

  Returns a set of physical counts and inventory adjustments for the
provided [CatalogObject](#type-catalogobject) at the requested
[Location](#type-location)s.

Results are paginated and sorted in descending order according to their
`occurred_at` timestamp (newest first).

There are no limits on how far back the caller can page. This endpoint can be
used to display recent changes for a specific item. For more
sophisticated queries, use a batch endpoint.
*/
func (a *Client) RetrieveInventoryChanges(params *RetrieveInventoryChangesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RetrieveInventoryChangesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRetrieveInventoryChangesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RetrieveInventoryChanges",
		Method:             "GET",
		PathPattern:        "/v2/inventory/{catalog_object_id}/changes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RetrieveInventoryChangesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RetrieveInventoryChangesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RetrieveInventoryChanges: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RetrieveInventoryCount retrieves inventory count

  Retrieves the current calculated stock count for a given
[CatalogObject](#type-catalogobject) at a given set of
[Location](#type-location)s. Responses are paginated and unsorted.
For more sophisticated queries, use a batch endpoint.
*/
func (a *Client) RetrieveInventoryCount(params *RetrieveInventoryCountParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RetrieveInventoryCountOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRetrieveInventoryCountParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RetrieveInventoryCount",
		Method:             "GET",
		PathPattern:        "/v2/inventory/{catalog_object_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RetrieveInventoryCountReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RetrieveInventoryCountOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RetrieveInventoryCount: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RetrieveInventoryPhysicalCount retrieves inventory physical count

  Returns the [InventoryPhysicalCount](#type-inventoryphysicalcount)
object with the provided `physical_count_id`.
*/
func (a *Client) RetrieveInventoryPhysicalCount(params *RetrieveInventoryPhysicalCountParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RetrieveInventoryPhysicalCountOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRetrieveInventoryPhysicalCountParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RetrieveInventoryPhysicalCount",
		Method:             "GET",
		PathPattern:        "/v2/inventory/physical-count/{physical_count_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RetrieveInventoryPhysicalCountReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RetrieveInventoryPhysicalCountOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for RetrieveInventoryPhysicalCount: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
