// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// CashDrawerShift This model gives the details of a cash drawer shift.
// The cash_payment_money, cash_refund_money, cash_paid_in_money,
// and cash_paid_out_money fields are all computed by summing their respective
// event types.
//
// swagger:model CashDrawerShift
type CashDrawerShift struct {

	// The amount of money added to the cash drawer for reasons other than cash
	// payments. It is computed by summing the events of type PAID_IN. The amount is
	// always greater than or equal to zero.
	CashPaidInMoney *Money `json:"cash_paid_in_money,omitempty"`

	// The amount of money removed from the cash drawer for reasons other than
	// cash refunds. It is computed by summing the events of type PAID_OUT. The amount
	// is always greater than or equal to zero.
	CashPaidOutMoney *Money `json:"cash_paid_out_money,omitempty"`

	// The amount of money added to the cash drawer from cash payments.
	// This is computed by summing all events with the types CASH_TENDER_PAYMENT and
	// CASH_TENDER_CANCELED_PAYMENT. The amount is always greater than or equal to
	// zero.
	CashPaymentMoney *Money `json:"cash_payment_money,omitempty"`

	// The amount of money removed from the cash drawer from cash refunds.
	// It is computed by summing the events of type CASH_TENDER_REFUND. The amount
	// is always greater than or equal to zero.
	CashRefundsMoney *Money `json:"cash_refunds_money,omitempty"`

	// The time when the shift was closed, in ISO 8601 format.
	ClosedAt string `json:"closed_at,omitempty"`

	// The amount of money found in the cash drawer at the end of the shift
	// by an auditing employee. The amount should be positive.
	ClosedCashMoney *Money `json:"closed_cash_money,omitempty"`

	// The ID of the employee that closed the cash drawer shift by auditing
	// the cash drawer contents.
	ClosingEmployeeID string `json:"closing_employee_id,omitempty"`

	// The free-form text description of a cash drawer by an employee.
	Description string `json:"description,omitempty"`

	// The device running Square Point of Sale that was connected to the cash drawer.
	Device *CashDrawerDevice `json:"device,omitempty"`

	// The IDs of all employees that were logged into Square Point of Sale at any
	// point while the cash drawer shift was open.
	EmployeeIds []string `json:"employee_ids"`

	// The time when the shift ended, in ISO 8601 format.
	EndedAt string `json:"ended_at,omitempty"`

	// The ID of the employee that ended the cash drawer shift.
	EndingEmployeeID string `json:"ending_employee_id,omitempty"`

	// The amount of money that should be in the cash drawer at the end of the
	// shift, based on the shift's other money amounts.
	// This can be negative if employees have not correctly recorded all the events
	// on the cash drawer.
	// cash_paid_out_money is a summation of amounts from cash_payment_money (zero
	// or positive), cash_refunds_money (zero or negative), cash_paid_in_money (zero
	// or positive), and cash_paid_out_money (zero or negative) event types.
	ExpectedCashMoney *Money `json:"expected_cash_money,omitempty"`

	// The shift unique ID.
	ID string `json:"id,omitempty"`

	// The time when the shift began, in ISO 8601 format.
	OpenedAt string `json:"opened_at,omitempty"`

	// The amount of money in the cash drawer at the start of the shift.
	// The amount must be greater than or equal to zero.
	OpenedCashMoney *Money `json:"opened_cash_money,omitempty"`

	// The ID of the employee that started the cash drawer shift.
	OpeningEmployeeID string `json:"opening_employee_id,omitempty"`

	// The shift current state.
	// See [CashDrawerShiftState](#type-cashdrawershiftstate) for possible values
	State string `json:"state,omitempty"`
}

// Validate validates this cash drawer shift
func (m *CashDrawerShift) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCashPaidInMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCashPaidOutMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCashPaymentMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCashRefundsMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClosedCashMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDevice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExpectedCashMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOpenedCashMoney(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CashDrawerShift) validateCashPaidInMoney(formats strfmt.Registry) error {

	if swag.IsZero(m.CashPaidInMoney) { // not required
		return nil
	}

	if m.CashPaidInMoney != nil {
		if err := m.CashPaidInMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cash_paid_in_money")
			}
			return err
		}
	}

	return nil
}

func (m *CashDrawerShift) validateCashPaidOutMoney(formats strfmt.Registry) error {

	if swag.IsZero(m.CashPaidOutMoney) { // not required
		return nil
	}

	if m.CashPaidOutMoney != nil {
		if err := m.CashPaidOutMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cash_paid_out_money")
			}
			return err
		}
	}

	return nil
}

func (m *CashDrawerShift) validateCashPaymentMoney(formats strfmt.Registry) error {

	if swag.IsZero(m.CashPaymentMoney) { // not required
		return nil
	}

	if m.CashPaymentMoney != nil {
		if err := m.CashPaymentMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cash_payment_money")
			}
			return err
		}
	}

	return nil
}

func (m *CashDrawerShift) validateCashRefundsMoney(formats strfmt.Registry) error {

	if swag.IsZero(m.CashRefundsMoney) { // not required
		return nil
	}

	if m.CashRefundsMoney != nil {
		if err := m.CashRefundsMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cash_refunds_money")
			}
			return err
		}
	}

	return nil
}

func (m *CashDrawerShift) validateClosedCashMoney(formats strfmt.Registry) error {

	if swag.IsZero(m.ClosedCashMoney) { // not required
		return nil
	}

	if m.ClosedCashMoney != nil {
		if err := m.ClosedCashMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("closed_cash_money")
			}
			return err
		}
	}

	return nil
}

func (m *CashDrawerShift) validateDevice(formats strfmt.Registry) error {

	if swag.IsZero(m.Device) { // not required
		return nil
	}

	if m.Device != nil {
		if err := m.Device.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("device")
			}
			return err
		}
	}

	return nil
}

func (m *CashDrawerShift) validateExpectedCashMoney(formats strfmt.Registry) error {

	if swag.IsZero(m.ExpectedCashMoney) { // not required
		return nil
	}

	if m.ExpectedCashMoney != nil {
		if err := m.ExpectedCashMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("expected_cash_money")
			}
			return err
		}
	}

	return nil
}

func (m *CashDrawerShift) validateOpenedCashMoney(formats strfmt.Registry) error {

	if swag.IsZero(m.OpenedCashMoney) { // not required
		return nil
	}

	if m.OpenedCashMoney != nil {
		if err := m.OpenedCashMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("opened_cash_money")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CashDrawerShift) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CashDrawerShift) UnmarshalBinary(b []byte) error {
	var res CashDrawerShift
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
