// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Payment Represents a payment processed by the Square API.
//
// swagger:model Payment
type Payment struct {

	// The amount processed for this payment, not including `tip_money`.
	//
	// The amount is specified in the smallest denomination of the applicable currency (for example,
	// US dollar amounts are specified in cents). For more information, see
	// [Working with Monetary Amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts).
	AmountMoney *Money `json:"amount_money,omitempty"`

	// The amount the developer is taking as a fee for facilitating the payment on behalf
	// of the seller. This amount is specified in the smallest denomination of the applicable currency
	// (for example, US dollar amounts are specified in cents). For more information,
	// see [Take Payments and Collect Fees](https://developer.squareup.com/docs/payments-api/take-payments-and-collect-fees).
	//
	// The amount cannot be more than 90% of the `total_money` value.
	AppFeeMoney *Money `json:"app_fee_money,omitempty"`

	// The buyer's billing address.
	BillingAddress *Address `json:"billing_address,omitempty"`

	// The buyer's email address.
	// Max Length: 255
	BuyerEmailAddress string `json:"buyer_email_address,omitempty"`

	// Non-confidential details about the source. The details are only populated if the
	// `source_type` is `CARD`.
	CardDetails *CardPaymentDetails `json:"card_details,omitempty"`

	// The timestamp of when the payment was created, in RFC 3339 format.
	// Max Length: 32
	CreatedAt string `json:"created_at,omitempty"`

	// The `Customer` ID of the customer associated with the payment.
	// Max Length: 191
	CustomerID string `json:"customer_id,omitempty"`

	// The action to be applied to the payment when the `delay_duration` has elapsed. This field
	// is read-only.
	//
	// Current values include `CANCEL`.
	DelayAction string `json:"delay_action,omitempty"`

	// The duration of time after the payment's creation when Square automatically applies the
	// `delay_action` to the payment. This automatic `delay_action` applies only to payments that
	// do not reach a terminal state (COMPLETED, CANCELED, or FAILED) before the `delay_duration`
	// time period.
	//
	// This field is specified as a time duration, in RFC 3339 format.
	//
	// Notes:
	// This feature is only supported for card payments.
	//
	// Default:
	//
	// - Card-present payments: "PT36H" (36 hours) from the creation time.
	// - Card-not-present payments: "P7D" (7 days) from the creation time.
	DelayDuration string `json:"delay_duration,omitempty"`

	// The read-only timestamp of when the `delay_action` is automatically applied,
	// in RFC 3339 format.
	//
	// Note that this field is calculated by summing the payment's `delay_duration` and `created_at`
	// fields. The `created_at` field is generated by Square and might not exactly match the
	// time on your local machine.
	DelayedUntil string `json:"delayed_until,omitempty"`

	// An optional ID of the employee associated with taking the payment.
	// Max Length: 192
	EmployeeID string `json:"employee_id,omitempty"`

	// A unique ID for the payment.
	// Max Length: 192
	ID string `json:"id,omitempty"`

	// The ID of the location associated with the payment.
	// Max Length: 50
	LocationID string `json:"location_id,omitempty"`

	// An optional note to include when creating a payment.
	// Max Length: 500
	Note string `json:"note,omitempty"`

	// The ID of the order associated with the payment.
	// Max Length: 192
	OrderID string `json:"order_id,omitempty"`

	// The processing fees and fee adjustments assessed by Square for this payment.
	ProcessingFee []*ProcessingFee `json:"processing_fee"`

	// The payment's receipt number.
	// The field is missing if a payment is canceled.
	// Max Length: 4
	ReceiptNumber string `json:"receipt_number,omitempty"`

	// The URL for the payment's receipt.
	// The field is only populated for COMPLETED payments.
	// Max Length: 255
	ReceiptURL string `json:"receipt_url,omitempty"`

	// An optional ID that associates the payment with an entity in
	// another system.
	// Max Length: 40
	ReferenceID string `json:"reference_id,omitempty"`

	// A list of `refund_id`s identifying refunds for the payment.
	RefundIds []string `json:"refund_ids"`

	// The total amount of the payment refunded to date.
	//
	// This amount is specified in the smallest denomination of the applicable currency (for example,
	// US dollar amounts are specified in cents).
	RefundedMoney *Money `json:"refunded_money,omitempty"`

	// Provides information about the risk associated with the payment, as determined by Square.
	// This field is present for payments to sellers that have opted in to receive risk
	// evaluations.
	RiskEvaluation *RiskEvaluation `json:"risk_evaluation,omitempty"`

	// The buyer's shipping address.
	ShippingAddress *Address `json:"shipping_address,omitempty"`

	// The source type for this payment.
	//
	// Current values include `CARD`.
	// Max Length: 50
	SourceType string `json:"source_type,omitempty"`

	// Additional payment information that gets added to the customer's card statement
	// as part of the statement description.
	//
	// Note that the `statement_description_identifier` might get truncated on the statement description
	// to fit the required information including the Square identifier (SQ *) and the name of the
	// seller taking the payment.
	StatementDescriptionIdentifier string `json:"statement_description_identifier,omitempty"`

	// Indicates whether the payment is APPROVED, COMPLETED, CANCELED, or FAILED.
	// Max Length: 50
	Status string `json:"status,omitempty"`

	// The amount designated as a tip.
	//
	// This amount is specified in the smallest denomination of the applicable currency (for example,
	// US dollar amounts are specified in cents). For more information, see
	// [Working with Monetary Amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts).
	TipMoney *Money `json:"tip_money,omitempty"`

	// The total amount for the payment, including `amount_money` and `tip_money`.
	// This amount is specified in the smallest denomination of the applicable currency (for example,
	// US dollar amounts are specified in cents). For more information, see
	// [Working with Monetary Amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts).
	TotalMoney *Money `json:"total_money,omitempty"`

	// The timestamp of when the payment was last updated, in RFC 3339 format.
	// Max Length: 32
	UpdatedAt string `json:"updated_at,omitempty"`
}

// Validate validates this payment
func (m *Payment) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmountMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAppFeeMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBillingAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBuyerEmailAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCardDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomerID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmployeeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocationID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNote(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProcessingFee(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReceiptNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReceiptURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReferenceID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRefundedMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRiskEvaluation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShippingAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTipMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Payment) validateAmountMoney(formats strfmt.Registry) error {
	if swag.IsZero(m.AmountMoney) { // not required
		return nil
	}

	if m.AmountMoney != nil {
		if err := m.AmountMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("amount_money")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateAppFeeMoney(formats strfmt.Registry) error {
	if swag.IsZero(m.AppFeeMoney) { // not required
		return nil
	}

	if m.AppFeeMoney != nil {
		if err := m.AppFeeMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("app_fee_money")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateBillingAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.BillingAddress) { // not required
		return nil
	}

	if m.BillingAddress != nil {
		if err := m.BillingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billing_address")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateBuyerEmailAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.BuyerEmailAddress) { // not required
		return nil
	}

	if err := validate.MaxLength("buyer_email_address", "body", m.BuyerEmailAddress, 255); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateCardDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.CardDetails) { // not required
		return nil
	}

	if m.CardDetails != nil {
		if err := m.CardDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("card_details")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateCreatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if err := validate.MaxLength("created_at", "body", m.CreatedAt, 32); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateCustomerID(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomerID) { // not required
		return nil
	}

	if err := validate.MaxLength("customer_id", "body", m.CustomerID, 191); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateEmployeeID(formats strfmt.Registry) error {
	if swag.IsZero(m.EmployeeID) { // not required
		return nil
	}

	if err := validate.MaxLength("employee_id", "body", m.EmployeeID, 192); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateID(formats strfmt.Registry) error {
	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("id", "body", m.ID, 192); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateLocationID(formats strfmt.Registry) error {
	if swag.IsZero(m.LocationID) { // not required
		return nil
	}

	if err := validate.MaxLength("location_id", "body", m.LocationID, 50); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateNote(formats strfmt.Registry) error {
	if swag.IsZero(m.Note) { // not required
		return nil
	}

	if err := validate.MaxLength("note", "body", m.Note, 500); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateOrderID(formats strfmt.Registry) error {
	if swag.IsZero(m.OrderID) { // not required
		return nil
	}

	if err := validate.MaxLength("order_id", "body", m.OrderID, 192); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateProcessingFee(formats strfmt.Registry) error {
	if swag.IsZero(m.ProcessingFee) { // not required
		return nil
	}

	for i := 0; i < len(m.ProcessingFee); i++ {
		if swag.IsZero(m.ProcessingFee[i]) { // not required
			continue
		}

		if m.ProcessingFee[i] != nil {
			if err := m.ProcessingFee[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("processing_fee" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Payment) validateReceiptNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.ReceiptNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("receipt_number", "body", m.ReceiptNumber, 4); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateReceiptURL(formats strfmt.Registry) error {
	if swag.IsZero(m.ReceiptURL) { // not required
		return nil
	}

	if err := validate.MaxLength("receipt_url", "body", m.ReceiptURL, 255); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateReferenceID(formats strfmt.Registry) error {
	if swag.IsZero(m.ReferenceID) { // not required
		return nil
	}

	if err := validate.MaxLength("reference_id", "body", m.ReferenceID, 40); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateRefundedMoney(formats strfmt.Registry) error {
	if swag.IsZero(m.RefundedMoney) { // not required
		return nil
	}

	if m.RefundedMoney != nil {
		if err := m.RefundedMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refunded_money")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateRiskEvaluation(formats strfmt.Registry) error {
	if swag.IsZero(m.RiskEvaluation) { // not required
		return nil
	}

	if m.RiskEvaluation != nil {
		if err := m.RiskEvaluation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("risk_evaluation")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateShippingAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.ShippingAddress) { // not required
		return nil
	}

	if m.ShippingAddress != nil {
		if err := m.ShippingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shipping_address")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateSourceType(formats strfmt.Registry) error {
	if swag.IsZero(m.SourceType) { // not required
		return nil
	}

	if err := validate.MaxLength("source_type", "body", m.SourceType, 50); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	if err := validate.MaxLength("status", "body", m.Status, 50); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateTipMoney(formats strfmt.Registry) error {
	if swag.IsZero(m.TipMoney) { // not required
		return nil
	}

	if m.TipMoney != nil {
		if err := m.TipMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tip_money")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateTotalMoney(formats strfmt.Registry) error {
	if swag.IsZero(m.TotalMoney) { // not required
		return nil
	}

	if m.TotalMoney != nil {
		if err := m.TotalMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total_money")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateUpdatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdatedAt) { // not required
		return nil
	}

	if err := validate.MaxLength("updated_at", "body", m.UpdatedAt, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this payment based on the context it is used
func (m *Payment) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAmountMoney(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAppFeeMoney(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBillingAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCardDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProcessingFee(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRefundedMoney(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRiskEvaluation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateShippingAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTipMoney(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTotalMoney(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Payment) contextValidateAmountMoney(ctx context.Context, formats strfmt.Registry) error {

	if m.AmountMoney != nil {
		if err := m.AmountMoney.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("amount_money")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) contextValidateAppFeeMoney(ctx context.Context, formats strfmt.Registry) error {

	if m.AppFeeMoney != nil {
		if err := m.AppFeeMoney.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("app_fee_money")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) contextValidateBillingAddress(ctx context.Context, formats strfmt.Registry) error {

	if m.BillingAddress != nil {
		if err := m.BillingAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billing_address")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) contextValidateCardDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.CardDetails != nil {
		if err := m.CardDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("card_details")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) contextValidateProcessingFee(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ProcessingFee); i++ {

		if m.ProcessingFee[i] != nil {
			if err := m.ProcessingFee[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("processing_fee" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Payment) contextValidateRefundedMoney(ctx context.Context, formats strfmt.Registry) error {

	if m.RefundedMoney != nil {
		if err := m.RefundedMoney.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refunded_money")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) contextValidateRiskEvaluation(ctx context.Context, formats strfmt.Registry) error {

	if m.RiskEvaluation != nil {
		if err := m.RiskEvaluation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("risk_evaluation")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) contextValidateShippingAddress(ctx context.Context, formats strfmt.Registry) error {

	if m.ShippingAddress != nil {
		if err := m.ShippingAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shipping_address")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) contextValidateTipMoney(ctx context.Context, formats strfmt.Registry) error {

	if m.TipMoney != nil {
		if err := m.TipMoney.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tip_money")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) contextValidateTotalMoney(ctx context.Context, formats strfmt.Registry) error {

	if m.TotalMoney != nil {
		if err := m.TotalMoney.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total_money")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Payment) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Payment) UnmarshalBinary(b []byte) error {
	var res Payment
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
