// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// CustomerFilter Represents a set of `CustomerQuery` filters used to limit the set of
// `Customers` returned by `SearchCustomers`.
//
// swagger:model CustomerFilter
type CustomerFilter struct {

	// A filter to select customers based on when they were created.
	CreatedAt *TimeRange `json:"created_at,omitempty"`

	// A filter to select customers based on their creation source.
	CreationSource *CustomerCreationSourceFilter `json:"creation_source,omitempty"`

	// A filter to [select customers by email address](https://developer.squareup.com/docs/docs/customers-api/cookbook/search-customers#search-by-email-address)
	// visible to the seller.
	// This filter is case insensitive.
	//
	// For [exact matching](https://developer.squareup.com/docs/docs/customers-api/cookbook/search-customers#exact-search-by-email-address), this filter causes the search to return customer profiles
	// whose `email_address` field value are identical to the email address provided
	// in the query.
	//
	// For [fuzzy matching](https://developer.squareup.com/docs/docs/customers-api/cookbook/search-customers#fuzzy-search-by-email-address),
	// this filter causes the search to return customer profiles
	// whose `email_address` field value has a token-wise partial match against the filtering
	// expression in the query. For example, with `Steven gmail` provided in a search
	// query, the search returns customers whose email address can be `steven.johnson&#64;gmail.com`
	// or `mygmail&#64;stevensbakery.com`. Email addresses are tokenized by replacing, by spaces,
	// punctuations including periods (`.`), underscores (`_`), and the `&#64;` symbols. A match is
	// found if a tokenized email address contains all the tokens in the search query,
	// irrespective of the token order.
	EmailAddress *CustomerTextFilter `json:"email_address,omitempty"`

	// A filter to select customers based on their group membership.
	//
	// The `group_ids` is a JSON object of the following general format:
	// ```
	// "group_ids": {
	// "any":  ["{group_a_id}", "{group_b_id}", ...],
	// "all":  ["{group_1_id}", "{group_2_id}", ...],
	// 'none": ["{group_i_id}", "{group_ii_id}", ...]
	// }
	// ```
	//
	// You can use any combination of the above `group_ids` fields (also known as `FilterValue` properties)
	// to specify how customers are selected based on their group membership.
	// With the `any` option, the search returns customers in Groups `A` or `B` or ... of the list.
	// With the `all` option, the search returns customers in Groups `1` and `2` and ... of the list.
	// With the `none` option, the search returns customers not in Groups `i` and not in `ii` and not in ... of the list.
	//
	// If any of the search conditions are not met, including when an invalid or non-existent group ID is provided, the result is an empty list.
	//
	// You can use the `group_ids` search filter with other available filters.
	//
	// You cannot use the `group_ids` filter to select customers based on segment membership.
	GroupIds *FilterValue `json:"group_ids,omitempty"`

	// A filter to [select customers by their phone numbers](https://developer.squareup.com/docs/docs/customers-api/cookbook/search-customers#search-by-phone-number) visible to the seller.
	// This filter is case insensitive.
	//
	// For [exact matching](https://developer.squareup.com/docs/docs/customers-api/cookbook/search-customers#exact-search-by-phone-number),
	// this filter causes the search to return customers whose phone number
	// matches the specified query expression. The number in the query must be of an E.164-compliant
	// form. In particular, it must include the leading `+` sign followed by a country code and then a
	// subscriber number. The standard E.614 form of a US phone number is `+12061112222` of
	// the domestic version or `+0012061112222` of the international version. The E.164-compliant
	// variations include `+1 (206) 111-2222` or `+001 (206) 111-2222`, respectively. To match
	// the query expression, stored customers' phone numbers are converted to the standard
	// E.164 form of the national and internationalized versions.
	//
	//
	// For [fuzzy matching](https://developer.squareup.com/docs/docs/customers-api/cookbook/search-customers#fuzzy-search-by-phone-number),
	// this filter causes the search to return customers whose phone number matches partially
	// the token or tokens provided in the query expression. For example, if the search query contains
	// `415-123-45`, the filter selects those customers with phone numbers of `415-123-4567` or
	// `234-151-2345`. The search does not return customers with the phone number of `415-123-4678`.
	// Similarly, if the search query contains `415` as part of the phone number, the search returns
	// those customers with phone numbers of `(415)-123-4567`, `(123) 415-1567`, and `1 (415) 123-4567`.
	PhoneNumber *CustomerTextFilter `json:"phone_number,omitempty"`

	// A filter to [select customers by their reference IDs](https://developer.squareup.com/docs/docs/customers-api/cookbook/search-customers#search-by-reference-id).
	// This filter is case insensitive.
	//
	// [Exact matching](https://developer.squareup.com/docs/docs/customers-api/cookbook/search-customers#exact-search-by-reference-id)
	// of a customer's reference ID against a query's reference ID is evaluated as
	// exact match between two strings, character by character in the given order.
	//
	// [Fuzzy matching](https://developer.squareup.com/docs/docs/customers-api/cookbook/search-customers#fuzzy-search-by-reference-id) of stored reference IDs against queried reference IDs works
	// exactly the same as fuzzy matching on email addresses. Non-alphanumeric characters
	// are replaced by spaces to tokenize stored and queried reference IDs. A match is found
	// if a tokenized stored reference ID contains all tokens specified in any order in the query. For example,
	// a query of `NYC M` will match customer profiles with the `reference_id` value of `NYC_M_35_JOHNSON`
	// and `NYC_27_MURRAY`.
	ReferenceID *CustomerTextFilter `json:"reference_id,omitempty"`

	// A filter to select customers based on when they were updated.
	UpdatedAt *TimeRange `json:"updated_at,omitempty"`
}

// Validate validates this customer filter
func (m *CustomerFilter) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreationSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmailAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroupIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReferenceID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CustomerFilter) validateCreatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if m.CreatedAt != nil {
		if err := m.CreatedAt.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("created_at")
			}
			return err
		}
	}

	return nil
}

func (m *CustomerFilter) validateCreationSource(formats strfmt.Registry) error {
	if swag.IsZero(m.CreationSource) { // not required
		return nil
	}

	if m.CreationSource != nil {
		if err := m.CreationSource.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("creation_source")
			}
			return err
		}
	}

	return nil
}

func (m *CustomerFilter) validateEmailAddress(formats strfmt.Registry) error {
	if swag.IsZero(m.EmailAddress) { // not required
		return nil
	}

	if m.EmailAddress != nil {
		if err := m.EmailAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("email_address")
			}
			return err
		}
	}

	return nil
}

func (m *CustomerFilter) validateGroupIds(formats strfmt.Registry) error {
	if swag.IsZero(m.GroupIds) { // not required
		return nil
	}

	if m.GroupIds != nil {
		if err := m.GroupIds.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("group_ids")
			}
			return err
		}
	}

	return nil
}

func (m *CustomerFilter) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.PhoneNumber) { // not required
		return nil
	}

	if m.PhoneNumber != nil {
		if err := m.PhoneNumber.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("phone_number")
			}
			return err
		}
	}

	return nil
}

func (m *CustomerFilter) validateReferenceID(formats strfmt.Registry) error {
	if swag.IsZero(m.ReferenceID) { // not required
		return nil
	}

	if m.ReferenceID != nil {
		if err := m.ReferenceID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reference_id")
			}
			return err
		}
	}

	return nil
}

func (m *CustomerFilter) validateUpdatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdatedAt) { // not required
		return nil
	}

	if m.UpdatedAt != nil {
		if err := m.UpdatedAt.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updated_at")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this customer filter based on the context it is used
func (m *CustomerFilter) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCreatedAt(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreationSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEmailAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGroupIds(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePhoneNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReferenceID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpdatedAt(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CustomerFilter) contextValidateCreatedAt(ctx context.Context, formats strfmt.Registry) error {

	if m.CreatedAt != nil {
		if err := m.CreatedAt.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("created_at")
			}
			return err
		}
	}

	return nil
}

func (m *CustomerFilter) contextValidateCreationSource(ctx context.Context, formats strfmt.Registry) error {

	if m.CreationSource != nil {
		if err := m.CreationSource.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("creation_source")
			}
			return err
		}
	}

	return nil
}

func (m *CustomerFilter) contextValidateEmailAddress(ctx context.Context, formats strfmt.Registry) error {

	if m.EmailAddress != nil {
		if err := m.EmailAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("email_address")
			}
			return err
		}
	}

	return nil
}

func (m *CustomerFilter) contextValidateGroupIds(ctx context.Context, formats strfmt.Registry) error {

	if m.GroupIds != nil {
		if err := m.GroupIds.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("group_ids")
			}
			return err
		}
	}

	return nil
}

func (m *CustomerFilter) contextValidatePhoneNumber(ctx context.Context, formats strfmt.Registry) error {

	if m.PhoneNumber != nil {
		if err := m.PhoneNumber.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("phone_number")
			}
			return err
		}
	}

	return nil
}

func (m *CustomerFilter) contextValidateReferenceID(ctx context.Context, formats strfmt.Registry) error {

	if m.ReferenceID != nil {
		if err := m.ReferenceID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("reference_id")
			}
			return err
		}
	}

	return nil
}

func (m *CustomerFilter) contextValidateUpdatedAt(ctx context.Context, formats strfmt.Registry) error {

	if m.UpdatedAt != nil {
		if err := m.UpdatedAt.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updated_at")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CustomerFilter) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CustomerFilter) UnmarshalBinary(b []byte) error {
	var res CustomerFilter
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
