// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// CatalogPricingRule Defines how discounts are automatically applied to a set of items that match the pricing rule
// during the active time period.
//
// swagger:model CatalogPricingRule
type CatalogPricingRule struct {

	// __Deprecated__: Please use the `exclude_products_id` field to apply
	// an exclude set instead. Exclude sets allow better control over quantity
	// ranges and offer more flexibility for which matched items receive a discount.
	//
	// `CatalogProductSet` to apply the pricing to.
	// An apply rule matches within the subset of the cart that fits the match rules (the match set).
	// An apply rule can only match once in the match set.
	// If not supplied, the pricing will be applied to all products in the match set.
	// Other products retain their base price, or a price generated by other rules.
	ApplyProductsID string `json:"apply_products_id,omitempty"`

	// Unique ID for the `CatalogDiscount` to take off
	// the price of all matched items.
	DiscountID string `json:"discount_id,omitempty"`

	// `CatalogProductSet` to exclude from the pricing rule.
	// An exclude rule matches within the subset of the cart that fits the match rules (the match set).
	// An exclude rule can only match once in the match set.
	// If not supplied, the pricing will be applied to all products in the match set.
	// Other products retain their base price, or a price generated by other rules.
	ExcludeProductsID string `json:"exclude_products_id,omitempty"`

	// If an `exclude_products_id` was given, controls which subset of matched
	// products is excluded from any discounts.
	//
	// Default value: `LEAST_EXPENSIVE`
	// See [ExcludeStrategy](#type-excludestrategy) for possible values
	ExcludeStrategy string `json:"exclude_strategy,omitempty"`

	// Unique ID for the `CatalogProductSet` that will be matched by this rule.
	// A match rule matches within the entire cart.
	// A match rule can match multiple times in the cart.
	// If no `ProductSet` is present, the rule will match all products.
	MatchProductsID string `json:"match_products_id,omitempty"`

	// User-defined name for the pricing rule. For example, "Buy one get one
	// free" or "10% off".
	Name string `json:"name,omitempty"`

	// A list of unique IDs for the catalog time periods when
	// this pricing rule is in effect. If left unset, the pricing rule is always
	// in effect.
	TimePeriodIds []string `json:"time_period_ids"`

	// Represents the date the Pricing Rule is valid from. Represented in RFC3339 full-date format (YYYY-MM-DD).
	ValidFromDate string `json:"valid_from_date,omitempty"`

	// Represents the local time the pricing rule should be valid from. Represented in RFC3339 partial-time format
	// (HH:MM:SS). Partial seconds will be truncated.
	ValidFromLocalTime string `json:"valid_from_local_time,omitempty"`

	// Represents the date the Pricing Rule is valid until. Represented in RFC3339 full-date format (YYYY-MM-DD).
	ValidUntilDate string `json:"valid_until_date,omitempty"`

	// Represents the local time the pricing rule should be valid until. Represented in RFC3339 partial-time format
	// (HH:MM:SS). Partial seconds will be truncated.
	ValidUntilLocalTime string `json:"valid_until_local_time,omitempty"`
}

// Validate validates this catalog pricing rule
func (m *CatalogPricingRule) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CatalogPricingRule) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CatalogPricingRule) UnmarshalBinary(b []byte) error {
	var res CatalogPricingRule
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
