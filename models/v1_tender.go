// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// V1Tender A tender represents a discrete monetary exchange. Square represents this
// exchange as a money object with a specific currency and amount, where the
// amount is given in the smallest denomination of the given currency.
//
// Square POS can accept more than one form of tender for a single payment (such
// as by splitting a bill between a credit card and a gift card). The `tender`
// field of the Payment object lists all forms of tender used for the payment.
//
// Split tender payments behave slightly differently from single tender payments:
//
// The receipt_url for a split tender corresponds only to the first tender listed
// in the tender field. To get the receipt URLs for the remaining tenders, use
// the receipt_url fields of the corresponding Tender objects.
//
// *A note on gift cards**: when a customer purchases a Square gift card from a
// merchant, the merchant receives the full amount of the gift card in the
// associated payment.
//
// When that gift card is used as a tender, the balance of the gift card is
// reduced and the merchant receives no funds. A `Tender` object with a type of
// `SQUARE_GIFT_CARD` indicates a gift card was used for some or all of the
// associated payment.
//
// swagger:model V1Tender
type V1Tender struct {

	// The brand of credit card provided.
	// See [V1TenderCardBrand](#type-v1tendercardbrand) for possible values
	CardBrand string `json:"card_brand,omitempty"`

	// The amount of total_money returned to the buyer as change.
	ChangeBackMoney *V1Money `json:"change_back_money,omitempty"`

	// The ID of the employee that processed the tender.
	EmployeeID string `json:"employee_id,omitempty"`

	// The tender's unique ID.
	// See [V1TenderEntryMethod](#type-v1tenderentrymethod) for possible values
	EntryMethod string `json:"entry_method,omitempty"`

	// The tender's unique ID.
	ID string `json:"id,omitempty"`

	// Indicates whether or not the tender is associated with an exchange. If is_exchange is true, the tender represents the value of goods returned in an exchange not the actual money paid. The exchange value reduces the tender amounts needed to pay for items purchased in the exchange.
	IsExchange bool `json:"is_exchange,omitempty"`

	// A human-readable description of the tender.
	Name string `json:"name,omitempty"`

	// The last four digits of the provided credit card's account number.
	PanSuffix string `json:"pan_suffix,omitempty"`

	// Notes entered by the merchant about the tender at the time of payment, if any. Typically only present for tender with the type: OTHER.
	PaymentNote string `json:"payment_note,omitempty"`

	// The URL of the receipt for the tender.
	ReceiptURL string `json:"receipt_url,omitempty"`

	// The total of all refunds applied to this tender. This amount is always negative or zero.
	RefundedMoney *V1Money `json:"refunded_money,omitempty"`

	// The time when the tender was settled, in ISO 8601 format.
	SettledAt string `json:"settled_at,omitempty"`

	// The time when the tender was created, in ISO 8601 format.
	TenderedAt string `json:"tendered_at,omitempty"`

	// The amount of total_money applied to the payment.
	TenderedMoney *V1Money `json:"tendered_money,omitempty"`

	// The total amount of money provided in this form of tender.
	TotalMoney *V1Money `json:"total_money,omitempty"`

	// The type of tender.
	// See [V1TenderType](#type-v1tendertype) for possible values
	Type string `json:"type,omitempty"`
}

// Validate validates this v1 tender
func (m *V1Tender) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateChangeBackMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRefundedMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTenderedMoney(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalMoney(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1Tender) validateChangeBackMoney(formats strfmt.Registry) error {

	if swag.IsZero(m.ChangeBackMoney) { // not required
		return nil
	}

	if m.ChangeBackMoney != nil {
		if err := m.ChangeBackMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("change_back_money")
			}
			return err
		}
	}

	return nil
}

func (m *V1Tender) validateRefundedMoney(formats strfmt.Registry) error {

	if swag.IsZero(m.RefundedMoney) { // not required
		return nil
	}

	if m.RefundedMoney != nil {
		if err := m.RefundedMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refunded_money")
			}
			return err
		}
	}

	return nil
}

func (m *V1Tender) validateTenderedMoney(formats strfmt.Registry) error {

	if swag.IsZero(m.TenderedMoney) { // not required
		return nil
	}

	if m.TenderedMoney != nil {
		if err := m.TenderedMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tendered_money")
			}
			return err
		}
	}

	return nil
}

func (m *V1Tender) validateTotalMoney(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalMoney) { // not required
		return nil
	}

	if m.TotalMoney != nil {
		if err := m.TotalMoney.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total_money")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1Tender) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1Tender) UnmarshalBinary(b []byte) error {
	var res V1Tender
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
