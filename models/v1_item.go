// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// V1Item V1Item
//
// swagger:model V1Item
type V1Item struct {

	// The text of the item's display label in Square Point of Sale. Only up to the first five characters of the string are used.
	Abbreviation string `json:"abbreviation,omitempty"`

	// If true, the item can be added to pickup orders from the merchant's online store. Default value: false
	AvailableForPickup bool `json:"available_for_pickup,omitempty"`

	// If true, the item can be added to shipping orders from the merchant's online store.
	AvailableOnline bool `json:"available_online,omitempty"`

	// The category the item belongs to, if any.
	Category *V1Category `json:"category,omitempty"`

	// The ID of the item's category, if any.
	CategoryID string `json:"category_id,omitempty"`

	// The color of the discount's display label in Square Point of Sale, if not the default color. The default color is 9da2a6.
	// See [V1ItemColor](#type-v1itemcolor) for possible values
	Color string `json:"color,omitempty"`

	// The item's description.
	Description string `json:"description,omitempty"`

	// The fees that apply to the item, if any.
	Fees []*V1Fee `json:"fees"`

	// The item's ID. Must be unique among all entity IDs ever provided on behalf of the merchant. You can never reuse an ID. This value can include alphanumeric characters, dashes (-), and underscores (_).
	ID string `json:"id,omitempty"`

	// The item's master image, if any.
	MasterImage *V1ItemImage `json:"master_image,omitempty"`

	// The modifier lists that apply to the item, if any.
	ModifierLists []*V1ModifierList `json:"modifier_lists"`

	// The item's name.
	Name string `json:"name,omitempty"`

	// Deprecated. This field is not used.
	Taxable bool `json:"taxable,omitempty"`

	// The item's type. This value is NORMAL for almost all items.
	// See [V1ItemType](#type-v1itemtype) for possible values
	Type string `json:"type,omitempty"`

	// The ID of the CatalogObject in the Connect v2 API. Objects that are shared across multiple locations share the same v2 ID.
	V2ID string `json:"v2_id,omitempty"`

	// The item's variations. You must specify at least one variation.
	Variations []*V1Variation `json:"variations"`

	// Indicates whether the item is viewable from the merchant's online store (PUBLIC) or PRIVATE.
	// See [V1ItemVisibility](#type-v1itemvisibility) for possible values
	Visibility string `json:"visibility,omitempty"`
}

// Validate validates this v1 item
func (m *V1Item) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFees(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMasterImage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModifierLists(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVariations(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1Item) validateCategory(formats strfmt.Registry) error {

	if swag.IsZero(m.Category) { // not required
		return nil
	}

	if m.Category != nil {
		if err := m.Category.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("category")
			}
			return err
		}
	}

	return nil
}

func (m *V1Item) validateFees(formats strfmt.Registry) error {

	if swag.IsZero(m.Fees) { // not required
		return nil
	}

	for i := 0; i < len(m.Fees); i++ {
		if swag.IsZero(m.Fees[i]) { // not required
			continue
		}

		if m.Fees[i] != nil {
			if err := m.Fees[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fees" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1Item) validateMasterImage(formats strfmt.Registry) error {

	if swag.IsZero(m.MasterImage) { // not required
		return nil
	}

	if m.MasterImage != nil {
		if err := m.MasterImage.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("master_image")
			}
			return err
		}
	}

	return nil
}

func (m *V1Item) validateModifierLists(formats strfmt.Registry) error {

	if swag.IsZero(m.ModifierLists) { // not required
		return nil
	}

	for i := 0; i < len(m.ModifierLists); i++ {
		if swag.IsZero(m.ModifierLists[i]) { // not required
			continue
		}

		if m.ModifierLists[i] != nil {
			if err := m.ModifierLists[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("modifier_lists" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1Item) validateVariations(formats strfmt.Registry) error {

	if swag.IsZero(m.Variations) { // not required
		return nil
	}

	for i := 0; i < len(m.Variations); i++ {
		if swag.IsZero(m.Variations[i]) { // not required
			continue
		}

		if m.Variations[i] != nil {
			if err := m.Variations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("variations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1Item) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1Item) UnmarshalBinary(b []byte) error {
	var res V1Item
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
